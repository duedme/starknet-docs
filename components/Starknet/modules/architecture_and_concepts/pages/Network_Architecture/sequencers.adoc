[id="sequencers"]
= Sequencers

Before diving in, make sure to check out the Architecture chapter for a quick exploration of Starknet’s sequencers, provers, and nodes.

Three main layers exist in blockchain: data availability, ordering, and execution. Sequencers have evolved within this evolving modular landscape of blockchain technology. Most L1 blockchains, like Ethereum, handle all these tasks. Initially, blockchains served as distributed virtual machines focused on organizing and executing transactions. Even roll-ups running on Ethereum today often centralize sequencing (ordering) and execution while relying on Ethereum for data availability. This is the current state of Starknet, which uses Ethereum for data availability and a centralized Sequencer for ordering and execution. However, it is possible to decentralize sequencing and execution, as Starknet is doing.

Each of these layers plays a crucial role in achieving consensus. First, the data must be available. Second, it needs to be put in a specific order. That’s the main job of a Sequencer, whether run by a single computer or a decentralized protocol. Lastly, you execute transactions in the order they’ve been sequenced. This final step, done by the Sequencer too, determines the system’s current state and keeps all connected clients on the same page.

== Introduction to Sequencers

The advent of Layer Two (L2) solutions like Roll-Ups has altered the blockchain landscape, improving scalability and efficiency. But what about transaction order? Is it still managed by the base layer (L1), or is an external system involved? Enter Sequencers. They ensure transactions are in the correct order, regardless of whether they’re managed by L1 or another system.

In essence, sequencing has two core tasks: sequencing (ordering) and executing (validation). First, it orders transactions, determining the canonical sequence of blocks for a given chain fork. It then appends new blocks to this sequence. Second, it executes these transactions, updating the system’s state based on a given function.

To clarify, we see sequencing as the act of taking a group of unordered transactions and producing an ordered block. Sequencers also confirm the resulting state of the machine. However, the approach explained here separates these tasks. While some systems handle both ordering and state validation simultaneously, we advocate for treating them as distinct steps.

image::sequencer-in-starknet.png[Sequencer in Starknet]

== Sequencer Role in the Starknet Network

Let’s delve into Sequencers by focusing on Madara and Kraken, two high-performance Starknet Sequencers. A Sequencer must, at least, do two things: order and execute transactions.

* *Ordering*: Madara handles the sequencing process, supporting methods from simple FCFS and PGA to complex ones like Narwhall & Bullshark. It also manages the mempool, a critical data structure that holds unconfirmed transactions. Developers can choose the consensus protocol through Madara’s use of Substrate, which offers multiple built-in options.

* *Execution*: Madara lets you choose between two execution crates: Blockifier and Starknet_in_Rust. Both use the Cairo VM for their framework.

We also have the Kraken Sequencer as another option.

* *Ordering*: It employs Narwhall & Bullshark for mempool management. You can choose from multiple consensus methods, like Bullshark, Tendermint, or Hotstuff.

* *Execution*: Runs on Starknet_in_Rust. Execution can be deferred to either Cairo Native or Cairo VM.

[cols="20,20,20"]
|===
|Feature |Madara |Kraken

|Ordering Method |FCFS, PGA, Narwhall & Bullshark |Narwhall & Bullshark

|Mempool Management |Managed by Madara |Managed using Narwhall & Bullshark

|Consensus Options |Developer’s choice through Substrate |Bullshark, Tendermint or Hotstuff

|Execution Crates |Blockifier, Starknet_in_rust |Starknet_in_rust

|Execution Framework |Cairo VM |Cairo Native or Cairo VM
|===

== Understanding the Execution Layer

* *Blockifier*: A Rust component in Starknet Sequencers, generates state diffs and blocks. It uses Cairo VM. Its goal is to become a full Starknet Sequencer.

* *Starknet_in_Rust*: Another Rust component for Starknet that also generates state diffs and blocks. It uses Cairo VM.

* *Cairo Native*: Stands out by converting Cairo’s Sierra code to MLIR.

== The Need for Decentralized Sequencers

For more details on the Decentralization of Starknet, refer to the dedicated subchapter in this Chapter.

Proving transactions doesn’t require to be decentralized (although in the near future Starknet will operate with decentralized provers). Once the order is set, anyone can submit a proof; it’s either correct or not. However, the process that determines this order should be decentralized to maintain a blockchain’s original qualities.

In the context of Ethereum’s Layer 1 (L1), Sequencers can be likened to Ethereum validators. They are responsible for creating and broadcasting blocks. This role is divided under the concept of "Proposer-Builder Separation" (PBS). Block builders form blocks (order the transactions), while block proposers, unaware of the block’s content, choose the most profitable one. This separation prevents transaction censorship at the protocol level. Currently, most Layer 2 (L2) Sequencers, including Starknet, perform both roles, which can create issues.

The drive toward centralized Sequencers mainly stems from performance issues like high costs and poor user experience on Ethereum for both data storage and transaction ordering. The challenge is scalability: how to expand without sacrificing decentralization. Opting for centralization risks turning the blockchain monopolistic, negating its unique advantages like network-effect services without monopoly.

With centralization, blockchain loses its core principles: credible neutrality and resistance to monopolization. What’s wrong with a centralized system? It raises the risks of censorship (via transaction reordering).

image::sequencer-centralized-rollup.png[Sequencer Centralized-Rollup]

A centralized validity roll-up looks like this:

1. *User Interaction & Selection*: Users send transactions to a centralized Sequencer, which selects and orders them.
2. *Block Formation*: The Sequencer packages these ordered transactions into a block.
3. *Proof & Verification*: The block is sent to a proving service, which generates a proof and posts it to Layer 1 (L1) for verification.
4. *Verification*: Once verified on L1, the transactions are considered finalized and integrated into the L1 blockchain.
